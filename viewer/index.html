<!DOCTYPE html>
<html>

<head>
   <meta charset="utf-8">
   <title>Viewer</title>

   <!-- This is what enables socket communication with the server. -->
   <script src="/socket.io/socket.io.js"></script>

   <style media="screen">
      body
      {
         background-color: #EEEEEE;
         font-family: sans-serif;
      }

      .canvas
      {
         border: 1px solid #CCCCCC;
         padding: 2px;
      }
   </style>

</head>

<body>

   <div id="canvasDiv" class="canvas">
      <canvas id="canvas"></canvas>
   </div>

   <hr/>

   <div style="display: none">
      <img id="bee" src="img/bee-transparent-small.png">
      <img id="obstacle" src="img/boulder.png">
   </div>

   <label>Show directional overlay: <input type="checkbox" id="directionOverlay" checked="true"></label>

   <h4>Information</h4>
   <table id="infoTable">
   </table>
</body>

<script>
   // get a socket object from the socket.io script included above
   var socket = io();

   var world = null;
   var height = 0;
   var width = 0;

   // get a reference to the canvas element
   var canvas = document.getElementById("canvas");

   // get image refs
   var bee      = document.getElementById("bee"     );
   var obstacle = document.getElementById("obstacle");

   // initalise selectionRectangle as an object
   var selectionRectangle =
   {
      active: false
   };

   // use this as a hash of ids -> booleans telling us which agents are selected
   var selectedAgents = {};

   // agent direction lookup table
   var agentRotations = {};

   socket.on('connect', function()
   {
      var clientId;
      var idx = document.cookie.indexOf("clientId");
      var endIdx = document.cookie.indexOf(";", idx);

      if (endIdx == -1)
      {
         endIdx = undefined;
      }

      clientId = document.cookie.slice(idx, endIdx).split("=").pop();

      socket.emit('clientId', clientId);
   });

   // This is where the magic happens. When we emit an "update" event from the
   // server, it'll come through here.
   socket.on('update', function(worldUpdate)
   {
      // First update
      if (world === null)
      {
         world = worldUpdate;
         world.width = width = world.x_limit * 2;
         world.height = height = world.y_limit * 2;
         canvas.setAttribute("width", world.width);
         canvas.setAttribute("height", world.height);
         document.getElementById("canvasDiv").style.width = world.width + "px";
         canvas.getContext("2d").translate(world.x_limit, world.y_limit);
         window.requestAnimationFrame(draw);
      }

      world = worldUpdate;
      world.height = height;
      world.width = width;

      for (var i = 0; i < world.agents.length; i++)
      {
         var agent = world.agents[i];

         if (selectedAgents[agent.id])
         {
            // Find an update all the information elements we created in the
            // selection process
            document.getElementById(`x${agent.id}`).innerHTML = Math.round(agent.x);
            document.getElementById(`y${agent.id}`).innerHTML = Math.round(agent.y);
            document.getElementById(`state${agent.id}`).innerHTML = agent.state;
         }
      }

      // This will instructs the browser to call the 'draw' function whenever
      // it's ready for a new animation frame
   });

   function draw()
   {
      // we draw to the 2d context, not the canvas directly
      var ctx = canvas.getContext("2d");

      // clear everything
      ctx.clearRect(-world.x_limit, -world.y_limit, world.width, world.height);
      ctx.save();
      ctx.fillStyle = "rgb(229, 229, 229)";
      ctx.fillRect(-world.x_limit, -world.y_limit, world.width, world.height);
      ctx.restore();

      for (var i = 0; i < world.sites.length; i++)
      {
         ctx.save();
         renderSite(world.sites[i], ctx);
         ctx.restore();
      }
      for (var i = 0; i < world.traps.length; i++)
      {
         ctx.save();
         renderTrap(world.traps[i], ctx);
         ctx.restore();
      }
      for (var i = 0; i < world.obstacles.length; i++)
      {
         ctx.save();
         renderObstacle(world.obstacles[i], ctx);
         ctx.restore();
      }

      ctx.save();
      renderHub(world.hub, ctx);
      ctx.restore();

      for (var i = 0; i < world.agents.length; i++)
      {
         // translating/rotating/etc. actually modifies the drawing context,
         // not any particular object, so we need to save it before and
         // restore it afterwards to get back to the baseline
         ctx.save();
         renderAgent(world.agents[i], ctx);
         ctx.restore();
      }

      if (document.getElementById("directionOverlay").checked)
      {
         ctx.save();
         renderAgentDirectionOverview(world.agents, ctx);
         ctx.restore();
      }

      if (selectionRectangle.active)
      {
         ctx.save();
         renderSelectionRectangle(ctx);
         ctx.restore();
      }

      window.setTimeout(() => { window.requestAnimationFrame(draw)}, 1000 / 60);
   }

   function renderAgent(agent, ctx)
   {
      // move the drawing context to the agent's x and y coords
      ctx.translate(agent.x, -agent.y);
      ctx.save();
      ctx.rotate(-agent.direction + Math.PI/2); // image is already orientated at PI/2


      ctx.drawImage(bee, -bee.width/2, -bee.height/2);
      ctx.restore();
      ctx.beginPath();

      // also draw a neat little selection box around the agent if it's selected
      if (selectedAgents[agent.id])
      {
         var outlineXy = (bee.width > bee.height) ? bee.width : bee.height;
         // move 7px up and left from agent's centre
         ctx.translate(-outlineXy/2 - 3, -outlineXy/2 - 3);
         ctx.strokeStyle = "rgb(24, 215, 255)";

         // draw a rectangle from origin (agent centre - (7px, 7px), to agent
         // centre + (7px, 7px) )
         ctx.strokeRect(0, 0, outlineXy + 3, outlineXy + 3);
      }
   }

   function renderSelectionRectangle(ctx)
   {
      ctx.fillStyle = "rgba(60, 181, 249, 0.2)";
      ctx.strokeStyle = "rgb(60, 181, 249)";
      ctx.lineWidth = 1;
      ctx.translate(-world.x_limit, -world.y_limit);

      // Don't translate the context like we did for agents because we have
      // canvas-relative coordinates already
      ctx.fillRect(selectionRectangle.x, selectionRectangle.y, selectionRectangle.width, selectionRectangle.height);
      ctx.strokeRect(selectionRectangle.x, selectionRectangle.y, selectionRectangle.width, selectionRectangle.height);
   }

   function renderSite(site, ctx)
   {
      var qVal = site[3];
      var rVal = (qVal > 0.5) ? (1.0 - qVal) * 2 : 1.0;
      var gVal = (qVal > 0.5) ? 1.0 : qVal * 2;
      ctx.fillStyle   = `rgba(${Math.round(255 * rVal)}, ${Math.round(255 * gVal)}, 70, 0.8)`;
      ctx.strokeStyle = "rgb(20, 20, 20)";
      ctx.translate(site[0], -site[1]);

      ctx.beginPath();
      ctx.arc(0, 0, site[2], 0, Math.PI * 2, false);
      ctx.fill();
      ctx.stroke();
   }

   function renderTrap(trap, ctx)
   {
      ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
      ctx.strokeStyle = "rgb(255, 0, 0)";
      ctx.translate(trap[0], -trap[1]);

      ctx.beginPath();
      ctx.arc(0, 0, trap[2], 0, Math.PI * 2, false);
      ctx.fill();
      ctx.stroke();
   }

   function renderObstacle(obs, ctx)
   {
      ctx.translate(obs[0], -obs[1]);
      var radius = obs[2] * 2;

      ctx.drawImage(obstacle, -radius/2, -radius/2, radius, radius);
   }

   function renderHub(hub, ctx)
   {
      ctx.fillStyle = "rgba(242, 179, 19, 0.4)";
      ctx.strokeStyle = "rgb(242, 179, 19)";
      ctx.lineWidth = 2;
      ctx.translate(hub[0], -hub[1]);

      var radius = (hub[2] < 20) ? 20 : hub[2];

      ctx.beginPath();
      ctx.arc(0, 0, radius, 0, Math.PI * 2, false);
      ctx.fill();
      ctx.stroke();
   }

   function renderRough(rough, ctx)
   {
      ctx.translate(rough[0], -rough[1]);

      ctx.beginPath();
      ctx.arc(0, 0, rough[2], 0, Math.PI * 2, false);
      ctx.fill();
   }

   function renderAgentDirectionOverview(agents, ctx)
   {
      var directions = {};

      for (var i = -180; i <= 180; i += 10)
      {
         directions[i] = 0;
         //console.log(i);
      }

      for (var agent of agents)
      {
         if (Math.sqrt(Math.pow(agent.x, 2) + Math.pow(agent.y, 2)) > (world.hub[2] < 20) ? 20 : world.hub[2])
         {
            // our view coords are a little different than the world coords
            var dir = Math.atan2(agent.y, agent.x);
            dir = Math.round(dir * 180/Math.PI);
            dir = Math.round(dir / 10) * 10;

            directions[dir]++;
         }
      }

      ctx.beginPath();

      for (var i = -180; i <= 180; i += 10)
      {
         ctx.save();
         ctx.rotate(-(i * Math.PI/180) - Math.PI/2); // rotate works with a clockwise angle, atan2 is counterclockwise and i have no idea why it's pi/2 off
         ctx.lineTo(0, (directions[i] + 50) + (5 * directions[i]) );
         ctx.restore();
      }

      ctx.stroke();
   }

   // when the canvas is clicked
   canvas.addEventListener("mousedown", function(e)
   {
      // unselect everything
      clearSelectedAgents();

      // initialise the selection rectangle
      selectionRectangle.active = true;
      selectionRectangle.x = e.clientX + window.pageXOffset; // these coords are relative to the canvas
      selectionRectangle.y = e.clientY + window.pageYOffset; // pageOffset in case the page has been scrolled

      // default height and width
      selectionRectangle.width = 1;
      selectionRectangle.height = 1;
   });

   // when the mouse is moved over the canvas
   canvas.addEventListener("mousemove", function(e)
   {
      if (selectionRectangle.active)
      {
         selectionRectangle.width = (e.clientX + window.pageXOffset) - selectionRectangle.x;
         selectionRectangle.height = (e.clientY + window.pageYOffset) - selectionRectangle.y;
      }
   });

   // when the mouse click is released over the canvas
   // TODO: change this to the whole document? would avoid funny behaviour
   // when mouse is released off of the canvas
   canvas.addEventListener("mouseup", function(e)
   {
      computeSelectedAgents();
      selectionRectangle.active = false;

      // Create the information table elements for selected agents
      // This is all a bit hacky, probably ought to pull in JQuery for a nicer
      // interface for all this
      var infoTableInnerHtml = "";

      var tableHeader = "<tr><th>ID</th><th>X</th><th>Y</th><th>State</th>\n";

      infoTableInnerHtml += tableHeader;

      for (var i = 0; i < world.agents.length; i++)
      {
         var agent = world.agents[i];

         if (selectedAgents[agent.id])
         {
            var agentInfo = `<tr>
               <td id='id${agent.id}'   >${agent.id}</td>
               <td id='x${agent.id}'    >${agent.x}</td>
               <td id='y${agent.id}'    >${agent.y}</td>
               <td id='state${agent.id}'   >${agent.state}</td>
               </tr>`;

            infoTableInnerHtml += agentInfo;
         }
      }

      // replace the infoTable element's innerHTML with what we constructed above
      document.getElementById("infoTable").innerHTML = infoTableInnerHtml;
   });

   function clearSelectedAgents()
   {
      selectedAgents = {};
   }

   function computeSelectedAgents()
   {
      var selectBounds = {};

      selectBounds.left   = (selectionRectangle.width  > 0) ? selectionRectangle.x                             : selectionRectangle.x + selectionRectangle.width;
      selectBounds.right  = (selectionRectangle.width  > 0) ? selectionRectangle.x + selectionRectangle.width  : selectionRectangle.x;
      selectBounds.top    = (selectionRectangle.height > 0) ? selectionRectangle.y                             : selectionRectangle.y + selectionRectangle.height;
      selectBounds.bottom = (selectionRectangle.height > 0) ? selectionRectangle.y + selectionRectangle.height : selectionRectangle.y;

      selectBounds.left   -= world.x_limit;
      selectBounds.right  -= world.x_limit;
      selectBounds.top    -= world.y_limit;
      selectBounds.bottom -= world.y_limit;

      for (var i = 0; i < world.agents.length; i++)
      {
         var agent = world.agents[i];

         var agentBounds =
         {
            left: agent.x - 5,
            right: agent.x + 5,
            top: -agent.y - 5,
            bottom: -agent.y + 5
         };

         if (rectIntersect(agentBounds, selectBounds))
         {
            selectedAgents[agent.id] = true;
         }
      }
   }

   function rectIntersect(a, b)
   {
      return !(b.left > a.right || b.right < a.left || b.top > a.bottom || b.bottom < a.top);
   }
</script>

</html>
